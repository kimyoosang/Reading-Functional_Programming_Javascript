# Chpater1. 함수형 길들이기

- 자바스크립트에서도 데이터 및 데이터를 다루는 함수에 대해 진지하게 고민하는 프로그래밍 패러다임이 필요한 시기가 도래했다
- 반드시 자문해봐야 할 애플리케이션의 설계요소들
  - **확장성**
    - 추가 기능을 지원하기 위해 계속 코드를 리팩터링해야 하는가?
  - **모듈화 용이성**
    - 파일 하나를 고치면 다른 파일도 영향을 받는가?
  - **재사용성**
    - 중복이 많은가?
  - **테스트성**
    - 함수를 단위 테스트하기 어려운가?
  - **헤아리기 쉬움**
    - 체계도 없고 다라가기 어려운 코드인가?

## **1.1 함수형 프로그래밍은 과연 유용한가?**

- 자바스크립트 맥락에서 보면, FP(Functional Programming) 사고방식은 자바스크립트만의 매우 표현적인 특성을 가다듬어, 깔금하면서도 모듈적인, 테그스타힉 좋고 간결한 코드를 작성하는데 도움이 된다. 결과적으로 업무 능률 또한 높아진다
- 자바스크립트 코드를 함수형으로 작성하면 대부분의 문제가 해결된다. 순수함수에 기반을 두고 이미 검증된 기법과 관례에 따라 구현하면 코드가 복잡해지더라도 헤어라기 쉬운 방향으로 작성할 수 있다

## **1.2 함수형 프로그래밍이란?**

- 함수형 프로그래밍이란, 한마디로 함수 사용을 강조하는 소프트웨어 개발 스타일이다
- FP에서는 눈앞에 맞닥뜨린 문제를 조금 다른 사고방식으로 접근해야 한다. 단지 어떤 결과를 만드는 함수를 적용하는 그런 단순한 차원의 문제가 아니다. 진짜 목표는 애플리케이션의 **부수효과를 방지**하고 **상태 변이를 감소**하기 위해 **떼이터의 제어 흐름과 연산을 추상**하는 것이다
- 예 1: HTML페이지에 텍스트를 보여주는 예시

  ```javascript
  document.querySelector("#msg").innerHTML = "<h1>Hello World</h1>";
  ```

  - 이 예제는 모든걸 하드 코딩한 단순한 프로그램이라서 메시지를 동적으로 표시할 수 없다. 내용이나 형식을 바꾼다든가. 타깃 요소를 달리한다든지 할 땐 표현식을 전부 재작성해야한다

- 예 1-1: 기존 코드에서 함수만 만들어 달라지는 부분만 매개변수로 바꾸기

  ```javascript
  function printMessage(elementId, format, message) {
    document.querySelector(
      `${elementId}`
    ).innerHTML = `<${format}>${message}<${format}>`;
  }
  ```

  - 나아지긴 했으나 아직 완벽하게 재사용 가능한 코드는 아니다. 메시지를 HTML 페이지 대신 파일에 쓴다면 어떨까?
  - 매개벼ㅓㄴ수가 단순한 스칼라 값이 아닌, 특정 기능을 함수에 추가하여 매개변수로 전달하는, 다시 말해 함수를 매개변수화 하는 전혀 다른 차원의 과정을 떠올려야 한다
  - 함수형 프로그램은 여러 함수를 서로 합성하고 평가해서 더 많은 기능을 탑재하는 것이 유일한 목표다

- 예: 1-2: 함수형으로 바꾼 printMessage

  ```javascript
  var printMessage = run(addToDom("msg"), h1, echo);
  printMessage("Hello World");
  ```

  - 함수형으로 바꾸면 재사용성과 믿음성이 좋고 이해하기 쉬운, 더 작은 조각들로 프로그램을 나눈 후, 전체적으로 더 헤아리기 쉬운 형태의 프로그램으로 다시 조합했다
  - 모든 함수형 프로그램이 이 기본 원리를 따른다
  - run함수는 세 함수를 마치 자전거 체인처럼 연결해서 한 함수의 반환값이 다른 함수의 입력값으로 전달되게끔 한다. 그래서 echo가 'Hello World'문자열을 반환하면 h1으로 전달되고, 마지막으로 이 함수의 결과값이 addToDom에 넘거난다

- 함수형 코드는 마치 알고리즘의 초기 조건을 조정하듯, 본연의 기능은 그대로 간직한 채 코드를 쉽게 변겨어하기 위해 코드 자체를 매개변수화하는 것이다. 이렇게 하면 내부 오직은 하나도 안 고치고도 예를 들어 printMessage가 메시지를 2회 표시하게, 헤더는 h2요소로, DOM대신 콘솔에 출력하게 변경하는 일도 수월해진다
- 함수형 프로그래밍을 온전히 이해하려면, 먼저 그 이면에 깔려있는 다음 기본 개념을 숙지해야 한다
  - **선언적 프로그래밍**
  - **순수함수**
  - **참조 투명성**
  - **불변성**

### **1.2.1 함수형 프로그래밍은 선언적**

- 함수형 프로그래밍은 큰 틀엣 선언적 프로그래밍 패러다임에 속한다. 내부적으로 코드를 어떻게 구현했는지, 데이터는 어떻게 흘러가는지 밝히지 않은 채 연산/작업을 표현하는 사상이다
- 자바, C#, C++ 드의 구조적/객체지향 언어의 명령형 프로그램은 어떤 결과를 내기 위해 시스템의 상태를 변경하는 구문을 위에서 아래로 죽 늘려놓은 순차열(수열)에 불과하다
- 명령형 프로그래밍은 컴퓨터에게 원하는 작업을 어떻게 하는지 상세히 알려준다. 이와 달리 선언적 프로그래밍은 프로그램의 **서술부**와 **평가부**를 분리하여, 제어 흐름이나 상태 변활를 특정하지 않고도 프로그램 로직이 무엇인지를 **표현식**으로 나타낸다
- 같은 작업이라도 함수형으로 접근하면, 개발자가 각 요소를 올바르게 작동시키는 일에만 전념하고 루프 제어는 시스템의 다른 파트에 일임할 수 있다
- 루프를 함수로 추상하면 ES6부터 새로 선보인 **람다 표현식**이나 **화살표 함수**를 쓸 수 있다. 람다 표현식은 함수 인수로 전달 가능한 익명 함수를 대체할 수 있는 깔끔한 수단이다
- 루프는 재사용하기도 어렵거니와 다른 연산에 끼워 넣기도 어려운 명령형 제어 구조물이다. 또 루푸는 성겨ㅓㄱ상 반복할 떄마다 값이나 상태가 계속 바뀐다. 함수형 프로그램은 **무상태성**과 **불변성**을 지향한다. 무상태 코드는 전역 상태를 바꾸거나 혼선을 일으킬 가능성이 전혀 없다. 상태를 두지 않으려면 부수효과와 상태 변이를 일으키지 않는 **순수함수**를 써야한다

### **1.2.2 순수함수와 부수효과**

- 함수형 프로그래밍은 순후함수로 구성된 불변 프로그램 구축을 전제로 한다
- 순수 함수의 특징
  1. 주어진 입력에만 의존할 뿐, 평가 도중 또는 호출 간 변경될 수 있는 숨겨진 값이나 외부 상태와 무관하게 작동한다
  2. 전역 객체나 레퍼런스로 전달된 매개변수를 수정하는 등 함수 스코프 밖에서 어떠한 변경도 일으키지 않는다
- 예: 불순한 상태인 increment함수

  ```javascript
  var counter = 0;
  function increment() {
    return ++counter;
  }
  ```

  - 여기서 counter는 임시적 전역 변수를 통해 접근한다. 그러므로 자신의 스코프에 없는 외부 변수 counter를 읽고 수정하는 분순함수다

- 부수효과가 발생하는 상황들
  - 전역 범위에서 변수, 속성, 자료구조를 변경
  - 함수의 원래 인수 값을 변경
  - 사용자 입력을 처리
  - 예외를 일으킨 해당 함수가 붙잡지 않고 그대로 예외를 던짐
  - 화면 또는 로그 파일에 출력
  - HTML 문서, 브라우저 쿠기, DB에 정의
- 함수형 프로그래밍은 모든 상태 변이를 근절하자는 건 아니고, 상태 변이를 줄이고 관리할 수 있는 프레임워크를 제공하여 순수/불순 함수를 구분하자는 것이다
- 예: 부수효과를 일으키는 명령형 showStudent함수

  ```javascript
  function showStudent(ssn) {
    let student = db.find(ssn);
    if (student !== null) {
      document.querySelector(
        `#${elementId}`
      ).innerHTML = `${student.ssn}, ${student.firstname}, ${student.lastname}`;
    } else {
      throw new Error("학생을 찾을 수 없습니다");
    }
  }
  showStudent("444-44-4444");
  ```

  - 이 함수는 확실히 자신의 스코프를 벗어나 몇 가지 부수효과의 파장을 일으킨다

  1. 변수 db를 통해 데이터에 접근하는데, 함수 서명에는 이런 매개변수가 없으니 이는 외부 변수이다. 문제는 이 변수가 실행중 언제라도 null을 참조하거나 호출 단계마다 상이한 값을 가리키면 결과값이 완전히 달라지고 프로그램의 무결성이 깨질 수 있다는 점이다
  2. elementId는 그 값이 언제라도 바뀔수 있는 전역 변수라 이 함수가 어쩔 도리가 없다
  3. HTML 요소를 직접 고친다. HTML문서(DOM)은 그 자체로 가변적인, 전역 공유자원이다
  4. 학생 레코드를 찾지 못해 예외를 던지면 전체 프로그램의 스택이 툭 풀리면서 종료될것이다

- 이 함수는 외부 자원에 의존하므로 코드가 유연하지 않고 다루기가 힘들뿐더러 테스트역시 어렵다
- 함수형으로 바꾸려면 두 가지를 개선해야 한다
  1. 긴 함수를 하나의 목적을 가진 짧은 함수로 각각 분리한다
  2. 함수가해야 할 작업에 필요한 인수를 모두 명시하여 부수효과 개수를 줄인다
- 먼저, 학생 레코드를 조회하는 일과 이를 화면에 그리는 일을 분리한다
- **커링**이라는 기법은 함수의 여러 인수를 부분적으로 나누어 세팅하는 것이다. find와 append 두 함수를 커링을 통해 쉽게 조합하여 실행 가능한 단항 함수로 나눈다
- 예: showStudent 프로그램을 분해

  ```javascript
  var find = curry((db, id) => {
    let obj = db.find(id);
    if (obj === null) {
      throw Error("객체를 찾을 수 없습니다");
    }
    return obj;
  });

  var csv = (student) => {
    `${student.ssn}, ${student.firstname}, ${student.lastname}`;
  };

  var append = curry((selector, info) => {
    document.querySelector(selector).innerHTML = info;
  });
  ```

  - 한 가지만 개선했는데도 장점이 눈에 띈다
    1. 재사용 가능한 컴포넌트 3개로 나뉘어 코드가 훨씬 유연해졌다
    2. 이렇게 잘게 나뉜 함수를 재사용하면 신경 써서 관리할 코드 크기가 확 줄기 때문에 생산성을 높일 수 있다
    3. 프로그램이 해야할 일들을 고수준에서 단계별로 명확하게 보여주는 선언적 스타일을 따르므로 코드 가독성이 향상된다
    4. 무엇보다 중요한건, HTML 객체와의 상호작용을 자체 함수로 빼내어 순수하지 않은 로직을 순수함수에서 배제했다는 점이다

- 부수효과를 줄임으로써 외부 조건 변화에 덜 취약한 프로그램이 되었다. find 함수를 자세히 보면 예외를 내는 별도의 null 체크 분기분이 포함되어 있다. 함수가 일관된 반환값을 보장하도록 해서 전체 함수 결과르 ㄹ예측 가능한 방향으로 유도하면 여러모로 이롭다. 이것이 바로 **참조 추명성**이라는 순수함수 본연의 특징이다

### **1.2.3 참조 투명성과 치환성**

- 참조 투명성은 순수함수를 정의하는 좀 더 공식적인 방법이며, 여기서 **순수성**이란 함수의 인수와 결과값 사이의 순수한 매핑 관계를 의미한다. 따라서 어떤 함수가 동일한 입력을 받았을 때 동일한 결과를 내면 이를 **참조 투명한**함수라고 한다
- - 참조투명한 함수는 코드를 테스트하기 쉽고 **전체 로직을 파악**하는 것도 쉽다. 참조 투명성 혹은 **등식 정합성**은 수학에서 나온 용어지만 프로그래밍 언어의 함수는 수학 함수처럼 움직이지 않기 때문에 참조 투명성은 전적으로 개발자의 숙제로 남는다

### **1.2.4 불변 데이터 유지하기**

- 불변 데이터는 한번 생성된 후에는 절대 바뀌지 않는다. 다른 언어도 그렇듯이 문자열, 숫자 등 자바스크립트의 모든 기본형(원시 자료형)은 처음부터 불변이다. 그러나 배열 등의 객체는 불변이 아니어서 함수 인수로 전달해도 원래 내용이 변경되어 부수효과가 발생할 소지가 남아있다
- **_함수형 프로그래밍은, 외부에서 관찰 가능한 부수 효과가 제거된 불변 프로그램을 작성하기 위해 순수함수를 선언적으로 평가하는 것이다_**

## **1.3 함수형 프로그래밍의 좋은점**

- FP로 개발한 자바스크립트 애플리케이션은 어떤 점이 좋은지 고수준에서 보자
  1. 간단한 함수들로 작업을 분해한다
  2. 흐름 체인으로 데이터를 처리한다
  3. 리액티브 패러다임을 실현하여 이벤트 중심으로 코드의 복잡성을 줄인다

### **1.3.1 복잡한 작업을 분해하도록 유도**

- 함수형 프로그램은 고수준에서 보면, 사실상 분해와 합성간의 상호작용이라 할 수 있다. 이러한 양면성 덕분에 함수형 프로그램은 모듈적으로, 효율적으로 동작한다. 모듈성의 단위, 곧 **작업 단위**는 바로 함수 자신이다
- 대개 함수형 사고는 이처럼 어떤 작업을 논리적 하위작업(함수)으로 분할하는 행위부터 시작된다
- 필요하다면 이렇게 나뉜 하위작업을 더 단순한 순수함수로 분해해서 독립적인 작업단위로 나타낼 수 있다. FP에서 모듈화는 **단일성**의 원리와 밀접한 관련이 있다. 함수는 저마다 한가지 목표만 바라봐야 한다는 것이다
- **합성**이라는 기법은, 두 함수를 합성하면 첫 번째 함수의 결과를 다음 함수에 밀어 넣는 새로운 함수를 만드는 것을 말한다

  ```javascript
  var showStudent = compost(append("#student-info"), csv, find(db));

  showStudent("444-44-4444");
  ```

  - find의 반환값은 csv에 줄 인수와 형식, 개수가 일치히야 하며, csv 역시 append가 쓸 수 있는 값을 반환해야 한다

- 함수형으로 합성한 코드는 전체 표현식의 으미를 개별 조각의 의미에서 추론할 수 있다
- 함수 합성은 고수준의 추상화를 통해 자세한 내막을 밝히지 않고도 코드가 수행하는 전 단계를 일목요연하게 나타낸다. compose는 다른 함수를 인수로 받으므로 **고계함수**라고 한다

### **1.3.2 데이터를 매끄럽게 체이닝하여 처리**

- **체인**은 ($또는 jQuery처럼) 같은 객체를 반환하는 순차적인 함수 호출이다. 체인도 합성처럼 코드를 간결명료하게 작성하게 하고, 함수형은 물론 리액티브 자바스크립트 라이브러리에서도 활발히 쓰인다
- 예: 복수 과목을 수강한 학생들의 평균 점수를 계산하는 명령형 프로그램

  ```javascript
  let enrollment = [
    { enrolled: 2, grade: 100 },
    { enrolled: 2, grade: 80 },
    { enrolled: 1, grade: 89 },
  ];

  var totalGrades = 0;
  var totalStudentsFoound = 0;
  for (let i = 0; i < enrollment.length; i++) {
    let student = enrollment[i];
    if (student !== null) {
      totalGrades += student.grade;
      totalStudentFound++;
    }
  }
  var average = totalGrades / totalStudentsFound; // 90
  ```

- 함수형 마음가짐으로 이 문제를 분해하면 세 가지 단계를 거쳐야 한다
  1. (수강 과목이 2개 이상인) 자료 집합을 적절히 선택한다
  2. 학생의 점수를 얻는다
  3. 평균 점수를 계산한다
- 각 단계에 해당하는 함수를 로대시JS로 묶으면 함수 체인이 형성된다. 함수 체인은 필요한 시점까지 실행을 미루는 **느긋한 평가**를 수행한다. 다른 데에선 전혀 쓸일이 없는 일련의 코드를 전부 실행하지 않아도 되니 CPU 부하가 줄어들어 성능이 좋아진다. 이렇게 하면 다른 함수형 언어에 기본 탭재된 **필요시 호출**동작을 효과적으로 모방할 수 있다

- 예: 복수 과목을 수강한 학생들의 평균 점수를 계산하는 함수형 프로그램

  ```javascript
  let enrollment = [
    { enrolled: 2, grade: 100 },
    { enrolled: 2, grade: 80 },
    { enrolled: 1, grade: 89 },
  ];

  _.chain(enrollment)
    .filter((student) => student.enrolled > 1)
    .pluck("grage")
    .average()
    .value();
  ```

### **1.3.3 복잡한 비동기 애플리케이션에서도 신속하게 반응**

- 리액티브 패러다임의 가장 큰 장점은, 더 높은 수준으로 코드를 추상하여 비동기, 이벤트 기반 프로그램을 설정하느라 반복되는 판박이 코드는 아예 잊고 비즈니스 로직에만 전념할 수 있게 해준다는 것이다
- 또 함수를 체인으로 묶고 함성하는 FP의 능력을 최대한 이끌어낼 수 있다
- 예: 어떤 학생의 SSN이 올바른 번호인지 검증하는 명령형 함수

  ```javascript
  var valid = false;
  var elem = document.querySelector("#student-ssn");
  elem.onkeyup = function (event) {
    if (val !== null && val.length !== 0) {
      val = val.replage(/^\s*|\-s/g, "");
      if (val.length === 9) {
        console.log(`올바른 SSN: ${val}!`);
        valid = true;
      }
    } else {
      console.log(`잘못된 SSN: ${val}!`);
    }
  };
  ```

  - 하려는 일은 단순한데 코드는 적잖이 복잔해보이고, 게다가 비즈니스 로직이 모두 한곳에 집중되어 있어 모듈성도 결여되어 있다
  - 무엇보다 외부 상태에 의존하는 탓에 재사용이 어렵다

- 함수형 프로르개밍에 기반을 둔 리액티브 프로그램은 순수함수를 이용하여 map, reduce처럼 많이 쓰는 연산으로 데이터를 처리할 수 있고 람다 표현식의 간결함을 누릴 수 있다는 이점이 있다
- 리액피트 패러다임은 **옵저버블**이라는 아주 중요한 장치를 매개로 움직인다. 옵저버블을 이용하면 데이터 스트림을 구독해서 원하는 연산을 우아하게 합성 및 체이닝하여 처리할 수 있다
- 예: 어떤 학생의 SSN이 올바른 번호인지 검증하는 함수형 함수

  ```javascript
  Rx.Obervable.fromEvent(document.querySelector("#student-ssn"), "keyup")
    .pluck("srcElement", "value")
    .map((ssn) => ssn.replace(/^\s*|\-s/g, ""))
    .filter((ssn) => ssn !== null && ssn.length === 9)
    .subscribe((validSsn) => {
      console.log(`올바른 SSN: ${validSsn}`);
    });
  ```

  - 수행하는 모든 연산이 완전한 불변이고 비즈니스 로직은 모두 개별함수로 나뉘었다

- FP는 불변성과 공유 상태를 엄격하게 통제하므로 멀티스레드 프로그램도 보다 직관적으로 작성할 수 있다

## **1.4 마치며**

- 순수함수를 사용한 코드는 전역 상태를 바꾸거나 깨뜨릴 일이 전혀 없으므로 테스트, 유지보수가 더 쉬운 코드를 개발하는데 도움이 된다
- 함수형 프로그래밍은 코드를 선언적으로작성하므로 헤아리기 쉽고 전체 애플리케이션의 가독성 역시 향상된다. 도 함수와 람다 표현식을 조합하여 깔끔하게 코딩할 수 있다
- 여러 원소로 구성된 컬렉션 데이터는 map, reudce 같은 연산을 함수 체인으로 ㅇ녀결하여 물 흐르듯 매끄럽게 처리할 수 있다
- 함수형 프로그래밍은 함수를 기본적인 구성 요소로 취급한다. 리는 일급/고계함수 개념에 기반을 두며 코드의 모듈성, 재사용성을 높인다
- 리액티브/함수형 프로그래밍을 융합하면 이벤트 기반 프로그램 특유의 복잡성을 줄일 수 있다
