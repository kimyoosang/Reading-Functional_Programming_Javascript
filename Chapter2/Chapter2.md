# Chapter2. 고계 자바스크립트

## **2.1 왜 자바스크립트인가?**

- 자바스크립트는 동적 형식이고 객체지향적 범용 언어이자, 지금까지 인류가 만든 모든 언어중 가장 널리 쓰이면서, 모바일 애플리케이션, 웹사이트, 웹 서버, 데스크톱, 임베디드 애플리케이션, 심지어 DB에 이르기까지 응용 문야가 실로 광대하다
- 특히 **웹 세상을 대표하는** 맹주 언어라는 점에서 지금가지 창조된 그 어느 언어보다 폭 넓 게 쓰이는 FP언어이다
- 자바스크립트 함수는 주요 **작업단위**로서 애플리케이션에게 할 일을 시키는 역할뿐만 아니라 객체 정의, 모둘 생성, 이벤트 처리 등의 책임도 맡는다

## **2.2 함수형 대 객체지향 프로그래밍**

- 객체지향과 함수형의 가장 중요한 차이점은 데이터(객체 속성)와 기능(함수)을 조직하는 방법에 있다
- 명령형 코드로 이루어진 객체지향 애플리케이션은 인스턴스 메서드를 통해 가변 상태로 노출하고 조작할 수 있도록, 객체 기반의 캡슐화에 지나치게 의존한 채 가변 상태의 무결성을 유지한다
- 결국 객체의 데이터와 잘게 나뉜 기능이 단단히 유착되어 응집도가 높은 패키시자 형성된다. 이는 객체지향 프로그램이 추구하는 목적이자, 모든 추상화의 주요 형태가 객체인 이유이다
- 함수형 프로그램은 호출자로부터 데이터를 숨길 필요 없이 소규모의, 아주 단순한 자료형만을 대상으로 움직인다. 만사가 불변이니 얼마든지 객체를 직접 만지작거려도 되지만, 객체 스코프 밖에 위치한 일반적인 함수를 거치는 편이 좋다. 한마디로, 데이터와 기능을 느슨하게 결합하는 것이다
- 함수형 코드는 잘게 나뉜 인스턴스 메서드 대신 여러 자료형에 두루 적용 가능하고 굵게 나뉜 연산에 더 의존한다. **함수는 함수형 패러다임의 주된 추상화 형태이다**
- 객체지향은 데이터와 데이터 관계의 본질에 초점을 두는 반면, 함수형의 관심사는 해야 할 일, 즉 기능이다

표 1: 객체지향, 함수형 프로그래밍의 중요한 특징을 비교한 표

|                   | 함수형                            | 객체지향형                             |
| :---------------- | :-------------------------------- | :------------------------------------- |
| 합성단위          | 함수                              | 객체(클래스)                           |
| 프로그래밍 스타일 | 선언적                            | 명령형                                 |
| 데이터와 기능     | 독립적인 순수함수가 느슨하게 결합 | 클래스 안에서 메서드와 단단한 결합     |
| 상태 관리         | 객체를 불변 값으로 취급           | 인스턴스 메서드를 통해 객체를 변이시킴 |
| 제어 흐름         | 함수와 재귀                       | 루프와 조건 분기                       |
| 스레드 안전       | 동시성 프로그래밍 가능            | 캡슐화하기 어려움                      |
| 캡슐화            | 모든 것이 불변이라 필요 없음      | 데이터 무결성을 지키기 위해 필요함     |

- 분명히 다른 패러다임이지만 둘을 모으면 아주 강력한 애플리케이션을 구축할 수 있다. 한편으론 애플리케이션을 구성하는 형식 간의 관계가 자연스러운 풍성한 도메인 모델을 손에 넣고, 다른 한편으로 이들 형식을 가지고 어떤 일을 할 수 있는 순수함수까지 거머쥘 수 있다
- 자바스크립트는 객체지향 + 함수형 언어이므로 함수형 자바스크립트로 개발할 때에는 상태 변화 관리에 특히 신경을 써야 한다

### 2.2.1 자바스크립트 객체의 상태 관리\*\*

- 프로그램의 **상태**란 어느 한 시점에 찍은 모든 객체에 저장된 데이터의 스냅샷이다
- 객체 상태를 보호하는 측면에서 자바스크립트는 최악의 언어 중 하나다. 자바스크립트 객체는 너무나 동적이어서 언제건 속성을 추가, 삭제, 수정할 수 있다
- 자바스크립트의 이런 특성 덕분에 속성을 동적으로 생성하는 등 개발자는 여러 가지 잔재주를 부릴 자유가 이ㅉ미나, 중대형 규모이 프로그램에서는 자칫 도저히 관리 안되는 코드로 발전할 소지가 있다
- 코드를 순수함수로 작동시키면 이해/관리하기가 쉽다. 순수 객체란 불변 기능을 지닌 불변 객체를 말한다

### **2.2.2 객체를 값으로 취급**

- 프로그래밍 언어에서 문자열과 숫자는 처음부터 불변 값이기 때무넹 가장 이해하기 쉬운 자료형이다. 함수형 프로그래밍에서는 이런 식으로 움직이는 형식을 **값**이라고 한다
- 불변성을 바탕으로 사고하려면 사실상 모든 객체를 값으로 취급해야 한다. 그래야만 객체가 도중에 바뀔지 모른다는 불안감을 갖지 않고 객체를 주고받는 함수를 구사할 수 있다
- 자바스크립트 객체는 속성을 넣어둔 가방에 지나지 않아 속성 값은 언제라도 바꿀 수 있다. 기본형 값은 변경할 수 없지만, 기본형을 가리키는 변수 상태가 바뀌기 때문이다
  = 상수 레퍼런스는 ES6부터 추가된 const 키워드로 선언한다. 값을 재할당하거나 래퍼런스를 다시 선언할 수 없다
- 그러나 const 만으로는 FP가 요구하는 수준의 불변성을 실현하기 어렵다. 어떤 변수에 값을 재할당하지 못하게 막는다 해도, 객체의 내부 상태가 변하는 것까지 봉쇄하지 못하기 때문이다

  ```javascript
  const student = new Student("Alonzo", "Church", "666-66-6666", "Princeton");
  student.lastname = "Morning"; //속성값이 바뀐다
  ```

- 그래서 더 엄격한 불변성 정책이 필요하다. 변이를 방지할 목적으로 캡슐화해도 좋은 전약이고, 객체 구조가 단순하면 **값 객체 패턴**도 괜찮은 방안이다. 값 객체는 객체의 동등성이 항등성이나 래퍼런스가 아닌 경우, 오직 값에 따라 좌우되는 객체이다. 일단 값 객체를 선언한 이후엔 그 객체는 절대 변하지 않는다
- 예 1: 우편번호를 구현한 zipCode

  ```javascript
  function zipCode(code, loacation) {
    let _code = code;
    let _location = location;

    return {
      code: function () {
        return _code;
      },
      location: function () {
        return _location;
      },
      fromString: function (str) {
        let parts = str.split("-");
        return zipCode(parts[0], parts[1]);
      },
      toString: function () {
        return _code + "-" + _location;
      },
    };
  }

  const princetonZip = zipCode("08544", "3345");
  princetonZip.toString(); //'08544-3345'
  ```

  - 메서드를 일부만 호출자게 공개하고 \_code, \_location를 의사-프라이빗 변수처럼 다루는 **객체 리터럴 인터페이스**를 반환하는 식으로 자바스크립트 함수를 이용하면 우편번호의 내부 상태 접근을 차단할 수 있다. 이런 변수는 **클로저**를 거쳐야만 객체 리터럴에 접근할 수 있다
  - 이렇게 반환된 객체는 사실상 변이를 일으키는 메서드가 전혀 없는 기본형처럼 작동한다. 따라서 toString 메서드는 순수함수가 아니지만 순수함수처럼 작동하면서 해당 객체를 순수한 문자열 형태로 나타낸다
  - 값 객체는 함수형/객체지향 모두 가볍고 다루기 편하다. const와 함께 쓰면 문자열, 숮자와 의미가 유사한 객체를 생성할 수 있다

- 예 2: 사본을 새로 만들어 반환하는 메서드

  ```javascript
  function coordinate(lat, long) {
    let _lat = lat;
    let _long = long;

    return {
      latitude: function () {
        return _lat;
      },
      longitude: function () {
        return _long;
      },
      translate: function (dx, dy) {
        return coordinate(_lat + dx, _long + dy);
      },
      toString: function () {
        return "(" + _lat + "," + _long + ")";
      },
    };
  }

  const greenwich = coordinate(51.4778, 0.0015);
  greenwich.toString(); //'(51.4778, 0.0015)'
  ```

  - (translate처럼) 사본을 새로 만들어 반환하는 메서드 역시 불변성을 구현하는 또 다른 수단이다
  - 값 객체는 함수형 프로그래밍의 영향을 받은 객체지향 디자인 패턴으로, 서로 다른 패러다임이 상호 보완적인 관계를 유지할 수 있음을 보여주는 또 다른 실례이다
  - 값 객체는 이상적인 패턴이긴 하지만, 그래도 실세계의 문제를 전부 모형화 하기엔 충분치 않다

- 실무에서는 레거시 객체와 상호작용하거나 (Person, Studend와 같은) 계층적 데이터를 처리하는 코드가 필요할 때가 생긴다. 자바스크립트에는 **Object.freeze**라는 방법이 있다

### **2.2.3 가동부를 깊이 동결**

- 자바스크립트의 새로운 클래스 구분 중에 불변 필드를 표시하는 키워드는 따로 없지만, writable처럼 숨겨진 메타속성을 제어하면 내부 조작이 가능하다
- Object.freeze()함수는 writable 속성을 false로 세팅해서 객체 상태를 못 바꾸게 동결한다
- 예 3: Person객체를 동결하기

  ```javascript
  const person = Object.freeze(new Person("Haskell", "Curry", "444-44-4444"));
  person.firstname = "Bob"; //허용되지 않는다
  ```

  - 위 코드를 실행하면 person의 속성은 모두 읽기 전용 상태로 바뀌어 속성을 변경하려고 하면 에러가 난다

- Object.freeze()는 상속한 속성까지 고정하므로 Student 인스턴스를 동결하면 이 객체의 프로토타입 체인을 따라가 Person이 물려준 속성 역시 모두 같은 방법으로 동결한다
- 그러나 중첩된 객체 속성가지 동결하는 건 불가능하다
- Object.freeze()는 얕은 연산이라서 확실히 동결하고 싶을 땐 한 객체의 중첩 구조를 일일이 수작업으로 동결해야 한다
- 어느 수준 이상의 불변성을 코드에 강제하는 기법을 몇 가지 제시했지만, 상태를 전혀 바꾸지 않는 애플리케이션이란 그리 현실적이지 않다. 따라서 자바스크립트 애플리케이션의 복잡다기함을 줄인다는 차원에서 원본 객체에서 새 객체를 만드는 엄격한 정책을 작용하면 큰 도움이 된다.
- 함수형으로 접근법해서 객체의 불변 상태를 한곳에서 관리하는 **렌즈**라는 기법도 있다

### **2.2.4 객체 그래프를 렌즈로 탐색/수정**

- OOP에서는 메서드를 호출해서 상태적 객체의 내부 내용을 바꾸는 일이 비일비재하다. 그 결과, 상태를 조회한 결과를 보장하기 어렵고 어떤 객체가 원래 그대로일 거라 기대했던 모듈은 기능 자체가 무용지물이 될 가능성이 있다
- 개발자가 직접 **카피 온 라이트**전략으로 메서드를 호출할 때마다 새 객체를 만들어 반환하는 방법도 있지만, 단언컨대 그 과정이 정말 따분하기 짝이없고 에러도 나기 십상이다
- **렌즈**, 또는 **함수형 래퍼런스**라고도 불리는 이 기법은 상태적 자료형의 속성에 접근하여 불변화하는 함수형 프로그래밍 기법이다
- 렌즈의 작동방식은 상태를 관리하고 복사하는 방법을 알고 있는 내부 저장소 컴포넌트를 이용한다는 점에서 카피온 라이트와 비슷하다
- 렌즈를 직접 구현할 필요는 없고, 람다JS라는 자바스크립트 라이브러리를 사용하면 된다. 기본적으로 람다JS는 전역 객체 R로 모든 기능을 노출한다. Person의 lastname속성은 R.lensProp을 써서 다음과 같이 렌즈로 감싸면 된다
- 예 4: 객체 그래프를 렌즈로 탐색/수정

  ```javascript
  var person = new Person("Alonzo", "Church", "444-44-4444");
  var lastnameLens = R.lenseProp("lastname");
  const newPerson = R.set(lastnameLens, "Morning", person);
  ```

  - 속성의 내용은 R.view로 꺼내본다

  ```javascript
  R.view(lastnameLens, person); //'Church'
  ```

  - R.set을 호출하면 원래 객체 상태는 그대로 유지한 채 새로운 값이 포함된 객체 사본을 만들어 반환한다

  ```javascript
  var newPerson = R.set(lastnameLens, "Morning", person)
  newPerson.lastname //"Morning"
  person.lastname = //Church
  ```

  - 대상이 레거시 객체든, 권한 밖에 있는 객체든, 렌즈는 물밑에서 조용히 객체를 다루게 해주는 중요한 장치다. 또 렌즈는 Person의 address같은 중첩 속성까지 지원한다

  ```javascript
  person.address = new Address(
    "US",
    "NJ",
    "Princeton",
    zipCode("08544", "1234"),
    "Alexander St."
  );

  //address.zip속성을 렌즈로 탐색한다
  const zipPath = ["address", "zip"];
  const zipLens = R.lens(R.path(zipPath), R.assocPath(zipPath));
  R.view(zipLens, person); //zipCode('08644', '1234')
  ```

  - 렌즈로 구현한 세터는 불변이라 중첩 객체를 변경해서 새 객체를 반환할 수 있다

  ```javascript
  var newPerson = R.set(zipLens, zipCode("90210", "5678", person));
  var newZip = R.view(zipLens, newPerson); ///zipCode('90210', '5678')
  var originalZip = R.view(zipLens, person); ///zipCode("08544", "1234")
  newZip.toString() !== originalZip.toString(); //true
  ```

- 렌즈는 불변 래퍼라는 보호막을 제공할 뿐만 아니라, 필드에 접근하는 로직을 객체로부터 분리하여 this에 의존할 일을 없애고, 어떤 객체라도 그 내용물에 접근하여 조작할 수 있는 강력한 함수를 내어주겠다는 FP 철학과도 잘 어올린다

## **2.3 함수**

- 함수형 프로그래밍에서 함수는 작업의 기본 단위이다. 만사가 함수를 중심으로 행해진다
- **함수**는 연산자를 적용하여 평가할 수 잇는 모든 호출 가능 표현식을 가리키며, 호출자에게 계산한 값 또는 undefined를 반환한다. FP의 함수는 수학책에 나오는 함수처럼 **사용 가능한 결과**를 낼 경우에만 유의미하며, 그 외에는 외부 데이터 ㅂ녀경 등의 부수효과를 일으킨다고 볼 수 있다

### **2.3.1 함수를 일급 시민으로**

- 자바스크립트 함수는 실제로 객체이기 때문에 **일급**이며, 일급 시민이라고도 한다
- 예 1: 일반적으로 선언하는 형식의 함수

  ```javascript
  function multipiler(a, b) {
    return a * b;
  }
  ```

- 예 2: 여러 방법으로 선언한 함수

  - 익명함수 또는 람다 표현식으로 변수에 할당하기

  ```javascript
  const square = function(x) { //익명 함수
    return x * x
  }
  const square= x => x * x

  //객체 속성에 메서드 형태로 할당할 수 있다
  const obj = {
    method: function(x) {
      retrun x * x
    }
  }
  ```

  - (많이 쓰이진 않지만) 생성자를 통해 함수를 인스턴스화 하는 방법도 있다. 생성자는 정규 매개변수 세트와 함수 본체, 그리고 new 키워드로 만든다

  ```javascript
  const multipiler = new Function("a", "b", "return a * b");

  multipiler(2, 3); //6
  ```

- 자바스크립트 함수는 모두 Function 형식의 인스턴스이다. 함수의 length 속성은 정규 메개변수 개수를 나타내며, apply()와 call() 메서드는 함수를 주어진 콘텐스트로 호출한다
- 익명 함수 표현식의 우변은 name 속성이 빈 함수 객체다. 익명 함수는 어떤 함수의 기능을 확장하거나 특화시킬 때 인수로 전달한다
- sort()같은 자바스크립트 함수는 값을 할당할 수 있으면서도 다른 함수도 인수로 받을 수 있으므로 고계함수 범주에 속한다

### **2.3.2 고계함수**

- 함수도 작동 원리는 일반 객체와 같아서 함수 인수로 전달하거나 함수를 반환받을 수 있다. 이런 함수를 **고계함수**라고 한다
- 자바스크립트 함수는 일급 + 고계여서 **여느 값이나 다름없다**. 즉, 자신이 받은 입력값을 기반으로 정의된 언젠가는 실행될 값에 디나지 않는다. 이는 모든 함수형 프로그래밍에 깊숙이 자리잡은 기본 원리이다
- 함수 체인을 구성할 때엔 전체 표현식의 요솔 실행할 프로그램 조각을 항상 함수명으로 가리킨다
- 작은 프로그램 조각에서 고계함수를 조합하여 유의미한 표현식을 만들기도 한다
- 예 1: 미국 거주자 명단을 출력하는 프로그램 (명령형)

  ```javascript
  function printPeoplentheUs(people) {
    for(let i=0l i< people.length; i++) {
      var thisPerson = people[i]
      if(thisPerson.address.country === 'US') {
        console.log(thisPerson)
      }
    }
  }

  printPeopleInTheUs([p1, p2, p3])
  ```

  - 자바스크립트 함수는 일급이라서 일단 변수에 할당한 뒤 나중에 실행하도 된다

- 예 2: 미국 거주자 명단을 출력하는 프로그램 (고계함수 사용)

  ```javascript
  function printPeople(people, selector, printer) {
    people.forEach(function(person) {
      if(selector(person ){
        printer(person)
      })
    })
  }

  const inUs = person => person.address.country === 'US'

  printPeople(people, inUs, console.log)
  ```

### **2.3.3 함수 호출 유형**

- 자바스크립트 함수는 호출 시점의 런타임 콘텐스트, 즉 함수 본체 내부의 this 값을 자유롭게 지정할 수 있으며 호출하는 방법도 다양하다

  1. 전역 함수로 호출

  - this 래퍼런스는 전역 개체, 또는 undefined(엄격 모드)를 가리킨다

  ```javascript
  function doWord() {
    this.myVar = "어떤 값";
  }
  doWord();
  ```

  2. 메서드로 호출

  - this 레퍼런스는 해당 메서드를 소유한 객체이다

  ```javascript

  var obj = {
    prop: '어떤 속성',
    getProp: function() {
      retrun this.prop
    }
  }
  obj.getProp()
  ```

  3. 앞에 new를 붙여 생성자로 호출

  - 새로 만든 객체의 레퍼런스를 암시적으로 반환한다

  ```javascript
  function MyType(arg) {
    this.prop = arg;
  }
  var someVal = new MyType("어떤 인수");
  ```

- 다른 프로그래밍 언어와는 달리 this 래퍼런스가 가리키는 대상은 어휘적 콘텍스트가 아니라 함수를 사용하는 방법에 따라 다라진다. 이런 특성 탓에 정말 이해하기 어려운 코드가 될 수 있으므로 함수가 실행되는 콘텍스트를 잘 살펴야 한다
- 함수형 코드에서는 this를 쓸일이 거의 없다

### **2.3.4 함수 메서드**

- 자바스크립트 함수는 프로토타입에 소속된 apply와 call 메서드로도 호출할 수 있다. API 사용자가 기존 함수에서 새 함수를 간단히 만들어 쓰는 용도로 많이 쓴다
- apply와 call의 사용방법은 같다. 전자는 인수 배열을, 후자는 인수를 목록으로 받는 점만 다르다. 첫 번째 인수 thisArg를 이용하면 함수 콘텍스트를 입맛에 맞게 바꿀 수 있다

  ```javascript
  Function.prototype.apply(thisArg, [매개변수 배열])
  Function.prototype.call(thisArg, arg1, arg2, ...)
  ```

- thisArg가 어떤 객체면 그 객체가 메서드의 호출자로 세팅된다. 그러나 thisArg가 null이면 전역 객체가 함수 콘텍스트가 되어 마치 전역 함수처럼 작동하는데, 엄격 모드에서 실행하면 실제 null값 그대로 세팅된다
- thisArg로 함수 컨텍스트를 바꿀 수 있기 때문에 별의별 기법이 끼를 펼칠 멍석이 깔린 셈이다. 함수형 프로그램은 콘텍스트 상태에 절대로 의존하지 않기 때문에 이런 꼼수는 통하지 않는다
- 전역 공유 객체, 객체 콘텍스트 등은 함수형 자바스크립트에서 거의 쓸모없는 개념이지만, 함수 콘텍스트는 잘 알아두어야 한다

## **2.4 클로저와 스코프**

- 자바스크립트가 탄생하기 전에는 클로저는 순수FP 언어에만 존재했고 특정 애플리케잇녀에 제한적으로만 사용됐다. 클로저를 가장 먼저 주요 개발 요소로 채탁한 자바스크립트는 개발자가 코드를 작성하는 방법에 상당한 변화를 가져왔다

```javascript
function zipCode(code, loacation) {
  let _code = code;
  let _location = location;

  return {
    code: function () {
      return _code;
    },
    location: function () {
      return _location;
    },
    fromString: function (str) {
      let parts = str.split("-");
      return zipCode(parts[0], parts[1]);
    },
    toString: function () {
      return _code + "-" + _location;
    },
  };
}
```

- zipCode 함수가 반환한 객체 리터럴이 이 함수 스코프 밖에 선언된 변수에 마음대로 접근할 수 있다. 즉 zipCode 실행 이후에도 그 결과 반환된 객체는 자신을 감싼 함수에 선언되었던 정보를계속 바락볼 수 있다
- 이는 자바스크립트에서 객체와 함수를 선언할 때 형성되는 클로저 덕분이다. 이런 식으로 데이터에 접근하면 여러 가지 실용적인 이점이 있다
  1. 프라이빗 변수를 모방
  2. 서버에서 데이터를 조회
  3. 블록 스코프에 변술ㄹ 묶어둘 때
- **클로저**는 함수를 선언할 당시의 환경에 함수를 묵어둔 자료구조다. 함수 성넝부의 물리적 위치에 의존하므로 **정적 스코프** 혹은 **어휘 스코프**라고도 한다. 함수가 자신을 둘러싼 주변 상태에 접근할 수 있기 때문에 클로저를 이용하면 명확하고 가독성 높은 코드를 작성할 수 있다
- 클로저는 고계함수를 응용한 함수형 프로그래밍뿐만 아니라 이벤트 처리 및 콜백, 프라이빗 변수 모방, 그리고 자바스크립트의 일부 약점을 보완하는 용도로도 유익하다
- 함수 클로저의 작동 규칙은 자바스크립트의 스코핑 규칙과 밀접한 관련이 있다. 스코프는 일련의 변수 바닝딩을 한데 모아 변수가 정의된 코드 영역을 확정하는데, 사실상 클로저는 함수의 스코프를 상속한 것이다. 자신의 부모를 래퍼런스로 가리킨다는 점에서는 객체의 메서드가 자신이 상속한 인스턴스 변수에 접근하는 방법이나 마찬가지다

- 예 1: 클로저 사용 예시

  ```javascript
  function makeAddFunction(amount) {
    function add(number) {
      return number + amount
    }
    return add
  }
  function aleExponentFunction(base) {
    function raise (exponent) {
      return Math.pow(base, exponent)
    }
    return rais
  }

  var addTenTo = makeAddFunction(10)
  addTenTo(10) //20

  var raisThreeTo = makeExponentialFunction(3)
  raiseThreeTo(@) //9
  ```

- 두 함수의 amount, base 변수는 더 이상 활성 스코프에 없지만 반환된 함수를 호출하면 여전히 되살릴 수 있다. 중첩된 두 함수 add, rais가 자신의 계산 로직뿐만 아니라 자신을 둘러싼 모든 변수의 스냅샷을 간직하고 있기 때문이다
- 일반적으로 함수의 클로저는 다음 두 가지를 포함한다

  1. 모든 함수 매개변수
  2. (전역 변수를 포함해서) 바깥 스코프에 위치한 모든 변수

- 예 2: 클로저

  ```javascript
  var outerVar = "Outer";
  function makeInner(params) {
    var innerVar = "Inner";

    function inner() {
      console.log(`${outerVar}, ${innerVar}, ${params}이 (가) 보여요!`);
      return inner;
    }

    var inner = makeInner("Params");
    inner();
  }
  ```

  - makeInner가 반환한 함수가 자신이 선언되엇던 스코프에 존재했던 변수들을 모두 기억해서 쓰레기통으로 들어가지 않게 붙잡아준다
  - 전역 스코프역시 이 클로저에 포함되어 있어 outerVar도 접근 가능하다

- 함수 선언부 다음에 선언된 변수가 어떻게 클로저의 일부로 편입된건지 알기 위해서는 자바스크립트의 세 가지 스코프, 즉 **전역 스코프, 함수 스코프, 의사 블록 스코프**를 이해해야 한다

### **2.4.1 전역 스코프의 문제점**

- 전역 스코프는 가장 단순하면서도, 사장 나쁜 스코프이다. 전역 스코프에는 스크립트 최외곽에 선언된 객체 및 변수가 자리하고, 이들은 모든 자바스크립트 코드가 자유롭게 접근할 수 있다
- 함수형 프로그래밍에서는 관찰 다능한 어떤 변화도 함수에서 전파회는 것을 금기시하는데, 전역스코프에선 한 줄 한 줄이 그런 변화를 일으키는 원인이 될 수 있다
- 전역 변수는 페이지에 적재된 모든 스크립트가 공유하기 때문에 모듈 단위로 코드를 묶어두지 않으면 이름공간이 충돌할 소지가 매우 높다. 전역 이름공간을 더럽히면 다른 파일에서 선언된 변수, 함술ㄹ 예기치 않게 재정의 하는 문제도 발생할 수 있다
- 전역 데이터는 변수 상태가 언제 어떻게 바뀌는지 머릿속에서 따라가야 해서 점점 알 수 없는 프로그램을 만드는 부작용을 초래한다. 코드가 많아질수록 복잡도가 높아지는 주요우ㅠㅓㄴ인 중 하나다. 또 전역 데이터를 읽고 쓸라치면 어쩔 수 없이 외부에 의존하게 되어 함수가 부수효과를 유발하는 원인이 된다
- FP스타일로 개발할 땐 여하한 경우에도 전역 변수는 삼가야 한다

### **2.4.2 자바스크립트의 함수 스코프**

- **함수 스코프**는 자바스크립트가 선호하는 스코프 방식이다. 함수 내부에 선언된 변수는 모두 해당 함수의 지역 변수라서 다른 곳에서는 안 보이고, 함수가 반환되는 시점에 이들은 모두 바람과 함게 사라진다

  ```javascript
  function doWord() {
    let student = new Student(...)
    let address = new Address(...)
  };
  ```

  student와 address는 doWork 함수에 바인딩된 지역 변수라서 함수 밖에서는 접근 할 수 없다

- 자바스크립트 스코프는 다음과 같은 로직으로 작동한다
  1. 변수의 함수 스코프를 체크한다
  2. 지역 스코프에 없으면 자신을 감싼 바깥쪽 어휘 스코플 이동해서 전역 스코프에 도달할 때까지 변수 레퍼런스를 계속 찾는다
  3. 그래도 변수가 참조하는 대상이 없으면 undefined를 반환한다

### **2.4.3 의사 블록 스코프**

- 표준 ES5 자바스크립트는 for, while, if ,switch 처럼 제어 구조를 중괄호({})로 감싼 블록 수준의 스코프를 지원하지 않는다. 단, catch블록에 전달된 error 변수는 예외이다
- 자바스크립트의 함수 스코프는 참으로 독특해서 블록 안에 선언된 변수는 함수 어디서건 접근 가능하다

  ```javascript
  function doWord() {
    if (!myVar) {
      var myVar = 10;
    }
    console.log(myVar); //10
  }
  doWork();
  ```

- myVar 변수는 if문 내부에 선언했지만 if 블록 밖에서도 보인다
- 자바스크립트는 내부적으로 변수와 함수 선언부를 현재 스코프 제일 위쪽으로 호이스팅하기 때문에 이런일이 발생한다. 그래서 루프를 쓸 때도 안전하지 않게 되는 경우가 있다

- 예 1: 모호한 루프 카운터 문제

  ```javascript
  var arr = [1, 2, 3, 4];

  function processArr() {
    function multipleBy10(val) {
      i = 10;
      return val * i;
    }

    for (var i = 0; i < arr.length; i++) {
      arr[i].multipleBy10(arr[i]);
    }
    return arr;
  }

  processArr(); //[10,2,3,4]
  ```

- 루프 카운터 i는 processArr 함수의 최상단으로 이동하여 선언되고 multipleBy10 함수의 클로저에 포함된다. multipleBy10 내부로 스코프가 한정된 변수 i를 선언하려면 var 키워드를 썼어야 했는데 누락하는 바람에 루프 카운터가 뜻하지 않게 10으로 변경된다
- 루프 카운터는 i는 processArr 최상단으로 호이스팅되어 선언만 먼저 되고 루프가 시작되면 0 값이 할당된다
- EX6부터는 let 키워드로 루프 카운터를 해당 루프 블록에 바인딩하여 모호함을 어느 정도 극복할 수 있다

  ```javascript
  for (let i = 0; i < arr.length; i++) {
    //...
  }
  i; // i ===undeifined

  //let을 쓰면 호이스팅 문제가 해소되고 i는 제 스코프에 위치하게 됩니다. 루프를 벗어나면 i는 정의되지 않은 변수입니다
  ```

### **2.4.4 클로저 응용**

- 클로저는 대규모 자바스크립트 프로그램 개발 시 요긴한 쓰임새가 많습니다. 함수형 프로그래밍에 한정되는 것은 아니지만, 클로저를 이용하면 자바스크립트의 독특한 함수 체제를 멋지게 활용할 수 있다
  1. 프라이빗 변수를 모방
  2. 서버 측 비동기 호출
  3. 가상의 블록 스코프 변수를 생성

**프라이빗 변수를 모방**

- 자바스크립트에는 프라이빗 변수/함수를 두어 객체 스코프에서만 접근 가능하게 만들 키워드가 따로 없다. 접근할 수 없으면 바꿀 수도 없을 테니 불변성을 지키려면 캡슐화가 필요하다
- 자바스크립트는 클로저를 이용하면 이를 비슷하게 흉내낼 수 있다
- 클로저는 전역 범위의 데이터 공유를 피하기 위해 전역 이름공간을 고나리하는 수단으로도 쓰인다. 실제로 자바스크립트 라이브러리나 모듈 개발자는 전체 모듈의 프라이빗 메서드와 데이터를 숨길 때 클로저를 적극 활용한다
- 이것을 **모듈 패턴**이라고 한다
- 내부 변수를 캡슐화하면서 전역 레퍼런스 개수를 줄이고 외부 세게에는 딱 필요한 기능만 표출하기 위해 즉시 실행 함수(IIFE)를 사용한다
- 예 1: 대략적인 모듈의 뼈대

  ```javascript
  var MyModule = (function MyModule(export) {
    let _myPrivateVar = ...;

    export.method1 = function() {
      //작업 수행
    }
    export.method2 = function() {
      //작업 수행
    }
    return export
  }(myModule || {}))
  ```

- MyModule 객체는 전역 스코프에 생성되고 function 키워드로 만든 함수 표현식은 스크립트가 적재되는 동시에 실행된다. \_myPrivateVar 등의 프라이빗 변수는 함수 스코프 안에 국한 되며 표출한 두 메서드를 에워싼 클로저 덕분에 다른 객체다 이 모듈의 모든 내부 속성에 안전하게 접근할 수 있다
- 수많은 상태 및 기능이 탐재된 객체를, 전역 공간에는 아무런 흔적도 남기지 않고 외부에 공개할 수 있다

**서버 측 비동기 호출**

- 자바스크립트의 일급 고계함수는 다른 함수에 콜백으로 건낼 수 있다. 콜백은 다른 프로그램에 영향을 끼치지 않고 이벤트를 가로채 처리할 때 유용한 장치다

- 예 1: 서버에 데이터를 요청한 다음 그 수신 여뷰를 통보받는 프로그램(응답을 처리하는 콜백 함수를 기존 방식으로 짠 코드)

  ```javascript
  getJSON(
    "/students",
    (students) => {
      (grades) => processGrades(grades), (error) => console.log(error.message);
    },
    (error) => console.log(error.message)
  );
  ```

- 고계함수 getJSON은 성공/실패 두 콜백 함수를 인수로 받는다. 이벤트 처리, 비동기 코드에서는 깊이 중첩된 함수 호출의 늪에 빠져 옴짝달싹 못하는 일이 흔한다
- 원격 서버 호출을 연달아 하면 이른바 '운명의 콜백 피라미드'가 형성되기 일쑤다. 깊숙이 중첩된 코드는 파악하기 어렵다

**가상의 블록 스코프 변수를 생성**

- 루프 카운터 문제 역시 클로저로 해결할 수 있다
- 자바스크립트는 블록 스코프 개념이 없어서 인위적으로 블록 스코프를 만드는 일이 관건이다. let을 써도 기존 루프 체제 문제는 어느 정도 해결되지만, 함수형으로 접근한다면 클로저와 함수 스코프를 적극 활용한 forEach가 정답이다
- 이제 루프 카운터와 다른 변수들을 스코프 내부에 묶느라 고민하지 않아도 마치 루프문에 함수 스코프 블록이 존재하는 것처럼 루프 본체를 효과적으로 감쌀 수 있다
