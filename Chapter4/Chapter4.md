# Chapter4. 재사용 가능한, 모듈적인 코드로

- 대규모 소프트웨어 프로젝트에서 매우 중요한 특성 중 하나인 **모듈성**은, 프로그램을 더 작고 독립적인 부분으로 나눌 수 있는 정도를 뜻한다
- 모듈적 프로그램은 자신을 구성하는 부속들로부터 자신의 의미를 도출할 수 있다는 점에서 뚜렷이 구분된다. 이들 부속 (하위 프로그램)은 다른 시스템에 그대로 또는 더 쪼개서 통합할 수 있는 재사용 가능한 컴포넌트이다. 개발자의 생산성을 높일 뿐만 아니라 코드 유지보수성 및 가독성을 향상시키는 데에도 도움이 된다

## **4.1 메서드 체인 대 함수 파이프라인**

### **4.1.1 메서드를 여럿 체이닝**

```javascript
_.chain(namse)
  .filter(isValid)
  .map((s) => s.replace(/_/, " "))
  .uniq()
  .map(_.startCase)
  .sort()
  .value();
```

- 위 코드는 명령형 코드에 비해 분명히 구조적으로 향상돘고 가독성도 엄청 좋아졌다. 다만, 자신을 소유한 객체에 부자연스럽게 매여있어 아쉽게도 체인에서 실행 가능한 메서드 가짓수가 줄고 코드의 표현성도 제약을 받는다
- 이 예제는 로대시JS가 제공하는 연산만 쓸 수 있기 때문에 다른 라이브러리 함수를 쉽게 연결할 수 없다
- 여기서 체인을 끊어버리고 독립적인 함수열을 자유롭게 배열할 수 있게 하는 것이 바로 **함수 파이프 라인**이 필요한 이유다

### **4.1.2 함수를 파이프라인에 나열**

- 함수형 프로그래밍에서는 메서드 페이닝의 한계에서 벗어나, 출신에 관계없이 어떤 함수라도 유연하게 결합할 수 있다
- **파이프라인**이란 한 함수의 출력이 다음 함수의 입력에 되게끔 느슨하게 배열한, 방향성 함수 순차열이다
- 체이닝은 객체 메서드를 통해 함수들을 단단히 결합하지만, 파이프라인은 함수 입출력을 서로 연결 지어 느슨하게 결합된 컴포넌트를 만든다. 단, 함수의 향수(인수 개수)와 형식이 호환되지 않으면 연결할 수 없다

## **4.2 함수 호환 요건**

- 객체지향 프로그램에서는 파이프라인을 특정한 경우(보통 인증/인가 처리)에 드문드문 사용하지만, 함수형 프로그래밍에서는 파이프라인이 프로그램을 구축하는 유일한 수단이다
- 일을 하다 보면 대부분 정의된 문제와 그 해결 방안 간에 차이점이 생기게 마련이므로 단계별로 명확하게 정의된 계산을 해야한다. 이 계산 단계가 코드에서는 함수로 표현되는데, 각 함수는 두 가지 측면에서 입력과 출력이 호환돼야 한다
  1. 형식
  - 한 함수의 반환 형식과 수신 함수의 인수 형식이 일치해야 한다
  2. 함수
  - 수신 함수는 앞 단계 함수가 반환한 값을 처리하기 위해 적어도 하나 이상의 매개변수를 선언해야 한다

### **4.2.1 형식이 호환되는 함수**

- 함수 파이프라인을 설계할 때는 한 함수가 반환하는 것과 다른 함수가 받는 것이 반드시 호환되어야 한다. 형식은 정적 형식언어에서는 큰 관심사지만 자바스크립트는 형식이 느슨한 언어라서 그렇지 않다
- 어떤 객체가 실제로 특정 형식처럼 작동하면 그 형식은 그냥 그 객체의 형식인 것이다. 이것을 다른 말로 **덕 타이핑**이라고 한다
- 자바스크립트는 동적 파견 체제 덕분에 형식과 무관하게 객체에서 속성과 메서드를 가져올 수 있다. 매우 유연한 구조이지만, 함수가 어떤 형식의 값을 기대하는지 알아야 할 떄가 있어서 형식을 명확하게 정의하면 프로그램을 이해하는 게 더 쉬워진다

- 예 1: trim과 nrmalize로 함수 파이프라인을 수동으로 구성

  ```javascript

  const trim = (str) => str.replace(/^\s*|\s$/g,'')

  const normalize = (str) = str.replace(/\-g,'')

  normalize(trim('444-44-4444')) //444444444

  ```

  - 형식은 틀림없이 중요한 이슈지만, 자바스크립트에서는 함수가 취하는 인수 개수의 호환 여부가 더 중요하다

### **4.2.2 함수와 향수: 튜플**

- **향수**란 함수가 받는 인수의 개수이다. 함ㅅ의 **길이**라고도 한다
- 다른 프로그래밍에서는 향수를 당연하게 생각하지만, FP에서는 함수에 선언된 인수의 개수가 참조 투명성의 당연한 결과로서 복잡도와 정확히 비례하는 경우가 많다. 가령 문자열 인수를 하나만 받는 함수는 서너 개 받는 함수보다 훨씬 단순하다고 볼 수 있다
- 인수가 1개인 순수함수는 한 가지 용도, 즉 단일 책임을 담당하므로 가장 단순한 함수라고 볼 수 있다. 함수의 인수를 가능한 한 적게 만들면 인수가 많은 함수보다 더 유연하고 다목적으로 활용할 수 있다
- 두 가지 다른 값을 동시에 반환하기 위해서는 함수형 언어는 **튜플**이라는 자료구조를 지원한다. 튜플은 유한 원소를 지닌 정렬된 리스트로, 보통 한 번에 두세 개 값을 묶어 (a,b,c)와 같이 사용한다
- 튜플은 형식이 다른 원소를 한데 묶어 다른 함수에 건네주는 일이 가능한 불변성 자료구조이다
- 함수간에 데이터를 반환할 때는 튜플이 유용하다
  1. 불변성
  - 튜플은 한번 만들어지면 나중에 내용을 못 바꾼다
  2. 임의 형식의 생성 방지
  - 튜플은 전혀 무관한 값을 서로 연관지을 수 있다. 단지 데이터를 묶겠다고 새로운 형식을 정의하고 인스턴스화하는 건 괜스레 데이터 모형을 복잡하게 할 뿐이다
  3. 이형 배열의 생성방지
  - 형식이 다른 원소가 배열에 섞여 있으면 형식을 검사하는 방어 코드를 수반하므로 다루기가 까다롭다ㅏ. 배열은 태생 자체가 동일한 형식의 객체를 담는 자료구조이다
- 자바스크립트는 스칼라 등의 함수형 언어와 달리 튜플 자료형을 처음부터 지원하지 않는다. 자바스크립트 개발자는 직접 알아서 자신만의 튜플을 구현하여 쓰면 된다
- 예 1: 형식화한 튜플 자요형

  ```javascript
  const Tuple = function () {
    const typeInfo = Array.prototype.slice.call(arguments);
    const _T = function () {
      const values = Array.prototype.slice.call(arguments);
      if (values.some((val) => vall === null || val === undefined)) {
        throw new ReferenceError("튜플은 null값을 가질 수 없습니다");
      }
      if (values.length !== typeInfo.length) {
        throw new TypeError("튜플 향수가 프로토타입과 맞지 않습니다");
      }
      values.forEach((val, index) => {
        this["_" + (index + 1)] = checkType(typeInfo[index])(val);
      }, this);
      Object.freeze(this);
    };
    _T.prototype.values = () => {
      return Object.keys(this).map((k) => this[k], this);
    };
    return _T;
  };
  ```

  - 튜플 객체는 크기가 고정된 불변성 자료구조로, 함수 간 통신에 사용 가능한 n개의 이형 값을 담을 수 있다
  - 예를 들어 간단히 Status같은 값 객체를 만들어 쓰면 이렇게 된다

  ```javascript
  const Status = Tuple(Boolean, String);
  ```

- 예 2: 투플을 이용한 inValid 함수

  ```javascript

  const trim = (str) => str.replace(/^\s*|\s$/g,'')

  const normalize = (str) = str.replace(/\-g,'')

  const isValid = function(str) {
  if(str.length === 0)
  return new Status(false,'잘못된 입력입니다. 빈 값일 리 없지요!')
  }
  else {
    return new Status(true, '성공!')
  }

  isValid(normalize(strim('444-44-4444'))) //(true, 성공)

  ```

  - ES6부터 지원하는 **해체 할당**과 조합하면 튜플 값을 변수로 깔끔하게 매필할 수 있다

- 예 3: StringPair 형식

  ```javascript
  const StringPair = Tuple(String, String);
  const name = (new StringPair("Barkley", "Rosser")[(first, last)] =
    name.value());
  first; //'Barkley'
  second; //'Rosser'

  const fullname = new StringPair("J", "Barkley", "Rosser"); //향수가 맞지 않아 에러가 발생한다
  ```

- 튜플로 함수 향수를 줄일 순 있지만, 튜플만으로 만족스럽지 못할 땐 더 나은 대체 방안이 있다. 향수를 추상하는 동시에 모듈성, 재사용성을 높이는 함수 커링이라는 방법이다

## **4.3 커리된 함수를 평가**

- 커링을 이해하려면 먼저, 일반(비커리된)평가와 커리된 평가의 차이점을 분명히 인지해야 한다. 자바스크립트에서는 비커리된 일반 함수를 호출할 때 인수가 모자라도 별문제 없이 실행된다. 이를테면 함수 f(a,b,c)를 호출할 때 a 값만 넣어도 자바스크립트 런타임은 b,c를 undefined로 자동 세팅하므로 f함수는 정상적으로 실행된다
- 인수를 선언하지 않고 함수 안에서 arguments 객체에 전적으로 의존하는 건 문제를 키울 위험이 있다
- 이와 다릴 모든 매개변수가 명시된 커리된 함수에 일부 인수만 넣어 호출하면, 함수가 실행되는게 아니라 모자란 나머지 인수가 다 채워지기를 기다리는 새로운 함수가 반환된다
- **커링**은 다변수 함수가 인수를 전부 받을 때까지 실행을 보류, 또는 '지연'시켜 단계별로 나뉜 단항 함수의 순차여러로 전환하는 기법이다
- 자바스크립트로는 자동으로 함수를 커리할 수 없으므로 어쩔 수 없이 직접 코드를 구현해야 한다
- 예 1: 람다JS 라이브러리를 사용하여 커리 구현

  ```javascript
  const checkType = R.curry((typeDef, obj) => {
    if (!R.is(typeDef, obj)) {
      let type = typeof obj;
      throw new TypeError(
        `형식 불인치: ${typeDef}이어야 하는데, [${type}]입니다`
      );
    }
    return obj;
  });

  checkType(String); //'Curry'
  checkType(Number)(3); //3
  checkType(Number)(3.5); //3.5

  let now = new Date();
  checkType(Date)(now); //now
  checkType(Object)({}); //{}
  ```

  - R.curry를 쓰면 인수 개수에 상관없이 순수 함수형 언어의 자동 커링 장치를 모방할 수 있다. 자동 커링은 선언된 인수 개수만큼 중첩된 함수 스코프를 인위적으로 생성하는 작업이라고 보면 된다

- 예 2: fullname을 커리한 코드

  ```javascript
  const fullname = function(first, last) {
    ....
  }

  //여러 인수가 다음과 같이 여러 단항 함수들로 바뀐다
  const fullname = function(first) {
    return function(last) {
      ...
    }
  }
  ```

- 커링은 실무에서는 유명한 다음 디자인 패턴을 구현할 때 많이 사용한다
  1. 함수 팩토리를 모방
  2. 재사용 가능한 모듈적 함수 템플릿을 구현

### **4.3.1 함수 팩토리를 모방**

- 객체지향 세계에서 인터페이스는 클래스가 반드시 구현해야 할 규약을 정해놓은 추상적 형식이다
- 예 1: 각각 저장소와 배열에 보관된 학생 객체를 조회하는 함수

  ```javascript
  const fechStudentFromDb = R.curry(function(db,ssn)) {
    return arr[ssn]
  }
  ```

  - 이 함수는 커리를 해놔서 일반 팩토리 메서드 findStudent로 평가하는 부분과 함수를 정희한 부분을 뗴어놓을 수 있다

  ```javascript
  const findStudent = useDb ? fetchStudentFromDb(db) : fetchStudentFromArray;

  findStudent("444-44-4444");
  ```

  - 이제 다른 모듈의 호출자는 실제 구현부를 알지 못해도 얼마든지 findStudent를 불러 쓸 수 있다

- 커링은 재사용 측명에서도 함수 템플릿을 여러 만들 수 있어 좋다

### **4.3.2 재사용 가능한 함수 템플릿 구현**

- 애플리케이션의 상태별로 로그를 나누어 처리하고 싶은 경우가 있다. 함수 템플릿은 생성 시점에 인수 개수를 기준으로 연관된 함수들을 묶어놓은 것이다
- 여기서 예제는 자바스크립트용 로깅 프레임워크인 Log4Js를 사용한다
- 예 1: 로거 함수 템플릿을 만듧

  ```javascript

  const logger = function(appender, layout, name, leval, message) {
    const appenders = [
      'alert': new Log4Js.JSAlertAppender(),
      'console':new Log4Js.BrowserConsoleAppender()
      ]
    const layouts = [
      'basic': new Log4Js.BasicLayout(),
      'json': new Log4Js.JSONLayout(),
      'xml': new Log4Js.XMLLAyout()
    ]
    const appender = appenders[appender]
    appender.setLayout(layouts[layout])
    const logger = new Log4Js.getLogger(name)
    logger.addAppender(appender)
    logger.log(level, message, null)
  }

  // 로거를 커리하면 상황별로 적합한 로거를 모두 한곳에서 관리하고 재사용할 수 있다
  const log = R.curry(logger)('alert','json','FJS')
  log('ERROR', '에러가 발생하였습니다!')

  //여러 에러 처리 구분을 하나의 함수나 파일로 구현하고 싶으면, 유연하게 마지막 매개변수를 제외한 나머지 매개변수를 부분 세팅하면 된다
  const log = R.curry(logger)('alert','basic','FJS','ERROR')
  logError('코드 404 에러가 발생했습니다')
  logError('코드 402 에러가 발생했습니다')
  ```

  - 내부적으로는 이 함수에 curry 함수를 연속 호출해서 결국 단항 함수 하나만 남을 것이다. 기본 함수에서 새 함수를 맏르고 매개변수는 몇개라도 전달 가능하니 인수가 정해질 때마다 단계별로 함수를 올릴 수 있다

- 재사용성이 획기적으로 향상되는 것도 장점이지만, 무엇보다 커링의 가장 중요한 의의는 다인수 함수를 단한 함수로 바꾼다는 것이다
- 커링의 부분 적용과 매개변수 바인딩은 자바스크립트에서도 어느 정도 지원되는 기법으로, 함수 파이프라인에 연결해도 잘 작동할 수 있도록 함수가 더 작은 함수를 만든다

## **4.4 부분 적용과 매개변수 바인딩**

- **부분 적용**은 함수의 일부 매개변수 값을 처음부터 고정시켜 함수가 더 작은 함수를 생성하는 기법이다. 쉽게 말해, 매개변수가 5개인 함수가 있을 때 3개의 값을 제공하면 나머지 두 매개변수를 취할 함수가 생겨난다
- 처링처럼 부분 적용도 함수의 길이를 직접 줄이는 임무를 수행하지만 방법은 조금 다르다. 커리된 함수가 사실상 부분 적용된 함수라서 두 기법을 혼동하는 사람들이 많다
- 가장 주된 차이점은 매개변수를 전달하는 메커니즘이다
  - 커링은 부분 호출할 때마다 단항 함수를 중첩 생성하며, 내부적으로는 이들을 단계별로 합성하여 최종 결과를 낸다. 커링은 여러 인수를 평가하는 식으로도 변용할 수 있어서 개발자가 평가 시점과 방법을 좌지우지 할 수 있다
  - 부분 적용은 함수 인수를 미리 정의된 값으로 묶음(할당한) 후, 인수가 적은 함수를 새로 만든다. 이 결과 함수는 자신의 클로저에 고정된 매개변수를 갖고 있으며, 후속 호출 시 **이미 평가를 마친**상태이다
- 커링은 부분적용을 자동화한 것이다. 이것이 두 기법의 가장 큰 차이다
- 예 1: 부분적용과 커링의 차이

  ```javascript
  //커링
  var curriedFn = function (a) {
    return function (b) {
      return function (c) {
        return a + "," + b + "," + c + "는 좋은 친구들입니다";
      };
    };
  };

  //부분 적용
  var partialAppliedFn = function (a) {
    return function (b, c) {
      return a + "," + b + "," + c + "는 좋은 친구들입니다";
    };
  };
  ```

### **4.4.1 언어의 핵심을 확장**

- 부분 적용은 String, Number 같은 핵심 자료형을 확장하여 언어의 표현성을 풍부하게 할 목적으로 사용할 수 있다. 단, 이렇게 언어를 확장하면 차후 플랫폼은 업그레이드 할 때 언어에 추가된 새 메서드와 충돌할 가능성이 있어 이식성은 떨어진다
- 예 1: 언어 확장

  ```javascript
  //처음 N개 문자를 얻는다
  String.prototype.first = _.partial(String.prototype.substring, 0, _);

  "Functional Programming".first(3); //'Fun'

  // 성명을 '성, 이름' 형식으로 바꾼다
  String.prototype.asName = _.partial(
    String.prototype.replace,
    /(\w+)/,
    "$2, $1"
  );

  "Alonze Church".asName(); //'Churtch, Alonzo'
  ```

  - 직접 함수를 구현하기 전에 최근 업데이트된 기능과 겹치는 부분이 있는지 미리 확인해야 한다

  ```javascript
  if (!String.prototype.first) {
    String.prototype.first = _.partial(String.prototype.substring, 0, _);
  }
  ```

- setTimeout 같은 지연 함수처럼 부분 적용이 통하지 않을 때에는 함수 바인딩을 써야 한다

### **4.4.2 지연된 함수에 바인딩**

- 소유 객체를 전제로 메서드를 다룰 때에는 함수 바인딩으로 콘텍스트 객체를 세팅하는 일이 중요하다. 이를테면 브라우저에서 setTimeout, setInterval 같은 함수의 this 레퍼런스는 전역 콘텍스트인 window 객체를 가리켜야 별 탈 없이 작동한다. 이때는 간단히 런타임에 undefined를 전달하면 된다
- 스케줄러만 있으면 함수 본체 안에 감싼 코드를 원하는 시간 이후에 실행시킬 수 있다. bind, partial 모두 다른 함수를 반환하는 함수라서 중첩하는 건 어렵지 않다
- 부분 적용, 커링 모두 유익한 기법이다. 가장 널리 쓰이는 커링은 함수의 인수를 미리 세팅하거나 부분 평가하기 위해 함수 기능을 추상한 래퍼를 만든다. 당연히 인수가 적은 함수가 인수가 많은 함수보다는 다루기 쉬우니 이렇게 하면 도움이 된다. 어느 기법을 택하든지, 함수를 여러 단항 함수들로 몸집을 줄이는 동시에, 맘대로 자신의 스코프 밖에 위치한 객체에 접근하지 못하게끔 적정한 개수의 인수를 공급하는 효과가 있다
- 필요한 데이터를 얻는 로직을 분리하면 재사용 가능한 함수로 만들 수 있다. 무엇보다, 함수의 합성을 단순화한다는 장점이 있다

## **4.5 함수 파이프라인을 합성**

- 함수형 프로그램의 목표는 합성을 유도하는 필요한 자룍조를 얻는것이다
- 부수효과 없는 함수는 외부 데이터에 절대 의존하지 않으며 필요한 정보는 반드시 인수를 통해서만 받는다. 합성을 하려면 반드시 함수에서 부수효과를 없애야 한다
- 순수함수들로 작성한 프로그램은 그 자체로 순수한 프로그램으로, 시스템의 다른 부분을 손대지 않아도 더 복잡한 프로그램의 일부로 합성할 수 있다

### **4.5.1 HTML 위젯에서 합성하기**

- 합성이란 아이디어 자체는 함수형 프로그래밍에만 있는 개념도 아니고 직관적이다. 웹페이지에서 HTML위젯을 배치하는 문제를 생각해보자. 복잡한 위젯은 단순화 위젯을 여러 개 합성해서 구성하고, 더 큰 위젯에 편입시킬 수도 있다
- 예를 들어 입력 텍스트 박스 3개와 빈 컨테이너를 합하면 학생 인적 사항 폼이 생긴다
- 이 폼을 다른 컴포넌트와 재조합하면 더 복잡한 컴포넌트인 전체 학생 콘솔 위젯을 만들수 있다
- 이 위젯은 인적 사항 폼과 주소 폼으로 **합성**된다

### **4.5.2 함수 합성: 서술과 평가를 구분**

- 함수 합성이란 한마디로 복잡한 작업을 한데 묶어 간단한 작업으로 쪼개는 과정이다
- 예 1: 람다JS 함수 R.compose로 두 순수함수를 합성하는 예시

  ```javascript
  const str =
    "We can only see a short distance ahead but we can see plenty there that neede to be done";

  const explode = (srt) => str.split(/\s+/);

  const count = (arr) => arr.length;

  const CountWords = R.compose(count, explode);

  countWords(str); //19
  ```

  - 이 코드는 읽기 편한 데다 함수 구성부만 얼핏 봐도 의미가 쉽게 와 닿는다. 여기서 흥미로운 사실은, countWords를 실행하기 전에는 아무 평가도 하지 않는다는 점이다
  - 합성이 끝나면 해당 인수(countWords에 전달하는 인수)를 받아 호출되기를 기다리는 또 다른 함수가 반환된다
  - **함수의 서술부와 평가부를 분리**하는 합성의 미학이다
  - countWords(str)를 호출하면 explde함수가 str을 인수로 받아 실행 후, 그 결과(문자열 배열)를 count에 전달하고 이 함수는 배열 크기를 계산한다. 합성은 함수의 출력과 입력을 연결하여 진정한 함수 파이프라인을 완성한다

- 합성을 할 때는 두 함수의 입출력 형식이 맞아야 합성이 가능하다
- 참조 투명한 함수는 사실상 한 객체를 다른 객체에 연결하는 화살표와 같다
- 이는 모듈화 시스템의 근간을 이루는, 소프트웨어 개발에서 아주 중요한 기본 원리이다. 형식이 호환되는 함수ㅡㄹㄹ 경계선 부근에서 느근하게 묶는 합성은 **인터페이스에 따른 프로그래밍**의 우너리와 일맥상통하다
- 자바스크립트 언어에서 합성은 기본 지원 대상이 아니지만 고계함수로 자연스럽게 표현할 방법이 있다
- 예 1: compose 구현부

  ```javascript
  function compose() {
    let args = arguments;
    let start = args.length - 1;
    return function () {
      let i = start;
      let result = args[start].apply(this, arguments);
      while (i--) {
        result = args[i].call(this, result);
      }
      return result;
    };
  }
  ```

- 합성이란 함수에만 국한된 것이 아니라, 전체 프로그램 역시 부수효과 없이 다른 프로그램/모듈을 합성해서 만들 수 있다
- 합성은 **결합 가능한 연산**이라서 논리 AND 연산자로 원소를 합칠 수 있다

### **4.5.3 함수형 라이브러리로 합성**

- 람다JS같은 함수형 라이브러리는 처음부터 커링을 염두에 두고 모든 함수를 구성했기 때문에 파이플인으로 합성하면 함수를 다용도로 사용할 수 있다
- 예 1: 학급에서 최고 점수를 받은 학생을 찾기

  ```javascript
  const students = ["Rosse", "Turing", "Church", "Kleene"];
  const grades = [80, 100, 90, 99];

  const smartestStudent = R.compose(
    R.headm
    R.pluck(0),
    R.reverse,
    R.sortBt(R.prop(1)),
    R.zip
  )

  smartestStudent(students, grades) //'Turing'
  ```

  - R.zip : 인접한 배열 원속끼리 서로 짝지어 새로운 배열을 만든다
  - R.props : 정렬할 값을 정한다. 하위 배열의 두 번째 원소인 점수를 가리키기 위해 인덱스 1을 넘기는 방식으로 처리한다
  - R.sortBy : 주어진 속성을 기본 오름차순으로 정렬한다
  - R.reverse : 전체 배열을 거꾸로 뒤집으로 첫 번째 원소가 최고 득접이 된다
  - R.pluck : 주어진 인덱스에 위치한 원소를 추출해서 새 배열을 만든다. 인덱스 0을 넘겨 학생 이름을 가리키게 한다
  - R.head : 첫 번째 언소를 얻는다

- 애플리케이션을 개발하다 보면 지역 저장소에서 데이터를 읽어 오거나 원격 HTTP 요청하는 등 부수효과를 피할수 없는 상황이 잦다. 따라서 순수 코드와 불순 코드를 반드시 떼어놓고 분별할 수 있어야 한다

### **4.5.4 순수/불순 함수 다루기**

- **불순한**코드는 실행 후 부수효과가 드러나고 외부 디펜던시 탓에 구성함수의 스코프 바깥에서 데이터에 접근할 수밖에 없다. 함수 하나만 불순해도 전체 프로그램이 금세 불순해지기 십상이다
- 함수형 프로그래밍의 덕을 보겠다고 100% 함수를 순수하게 만들 필요는 없다. 그렇게 하면 이상적이겠지만, 순수/불순한 코드가 어느 정도 섞여 있음을 받아들이되, 양쪽을 확실하게 구분하고 가급적 불순 코드를 격리하는 방법을 찾아야 한다. 이런 작업이 선행되어야 순수/불순 코드 조각을 합성하여 이어 붙일 수 있다

  ```javascript
  const showStudent = compose(append, csv, findStudent);
  ```

  - 이런 함수는 대부분 자신이 받은 인수를 통해 부수효과를 일으킨다
    - findStudent는 지역 객체 저장소 또는 외부 배열을 참조하는 레퍼런스를 사용한다
    - append는 HTML 요소를 직접 추가/수정 한다

- 각 함수의 불변 매개변수를 커링으로 부분 평가하여 프로그램을 조금이라도 개선하자. 입력 매개변수를 정제하는 코드를 추가하고, 여러 함수로 잘게 나누어 HTML 작업을 처리하는 방향으로 리팩터링 해보자
- 예 1: 커링 및 합성을 응용한 showStudent 프로그램

  ```javascript
  const findObject = R.curry(db,id) => {
    const obj = find(db,id)
    if(obj === null) {
      throw new Error(`ID가 [${id}]인 객체는 없습니다`)
    }
    return obj
  }

  const findStudent = findObject(FB('students'))

  const csv = ({ssn, firstname, lastname}) {
    `${ssn}, ${firstname}, ${lastname}`
  }

  const append = R.curry((elementId, Info) => {
    document.querySelector(elementId).innerHTML = info
    return info
  })

  const showStudent = R.compose(
    append('#student-info'),
    csv,
    findStudent,
    normalize,
    trim
  )

  showStudent('4444-4444') //444-44-4444, Alonzo Church
  ```

  - showStudent는 trim -> append 방향으로 네 함수가 거슬로 올라가면서, 한 함수의 출력을 다음 함수의 입력으로 전달한다
  - 함수를 합성하는 순서가 거꾸로라서 부자연스러워 보인다면 혹은 시각적으로 왼쪽부터 결합하는 식의 코드를 선호한다면, 람다JS에서 compose 대신 pipe 함수를 쓰면 유니기스 셸과 같은 방향으로 실행할 수 있다

  ```javascript
  const showStudent = R.pipe(
    trim,
    normalize,
    findStudent,
    csv,
    append("#student-info")
  );
  ```

### **4.5.5 무인수 프로그래밍**

- 무인수 프로그래밍으로 작성한 함수형 자바스크립트 코드는 하스켈 및 유닉스 철학에 기반을 둔 코드와 더 닮았다. 따라서 함수를 평가하는 저수준의 세부 사항은 신경 쓰지 않고 고수준의 컴포넌트를 합성하는 방향으로 사고방식을 전환함으로써 추상화 수준을 높일 수 있다
- 커링은 마지막 인수를 제외한 나머지 인수들을 유연하게 부분 정의하는 중요한 역할을 담당한다. 이런 스타일로 코딩하는 건 **암묵적 프로그래밍**이라고도 한다
- 이 함수들이 어떤 형식의 인수를 받는지, 전체 표현식 안에서 어떻게 연결되는지 아무 선언도 하지 않는다. 하지만 합성을 과용하면 모호하고 헷갈리는 프로그램이 될 수 있으니 유의해야 ㅎ나다
- 모든것을 무인수로 할 필요는 없다. 함수 합성을 두세 조각으로 나누는 편이 더 이로울 때도 있다
- 무인수 코드는 에러 처리, 디버깅을 할 때도 문제가 될 수있다. 예외를 던지는 부수효과가 무섭다고 해서 합성한 함수가 null을 반환하게 하면 안되고, 한 줄로 표현된 모든 명령어를 디버깅할 수 없기 때문이다

## **4.6 함수 조합기로 제어 흐름을 관리**

- **함수 조합기**란, 함수 또는 다른 조합기 같은 기본 장치를 조합하여 제어 로직처럼 작동시킬 수 있는 고계함수다. 조합기는 대부분 함수형 프로그램이 잘 흘러가도록 조정하는 일이 주임무라서 자신의 변수를 선언하거나 비즈니스 로직을 두진 않는다
- 함수 조합기중 가장 많이 쓰이는 것
  - 항등(identity)
  - 탭(tap)
  - 선택(alternation)
  - 순착열(sequence)
  - 포크(fork) 또는 조인(join)

### **4.6.1 항등(I-조합기)**

- identity 조합기는 주어진 인수와 똑같은 값을 반환하는 함수이다
- 주로 함수의 수학적 속성을 살펴보는 용도로 쓰이지만 실용적인 쓰임새도 있다
  - 무인수 코드를 작성할 때, 함수 인수를 평가하는 시점에 데이터를 고계함수에 제공한다
  - 함수 조합기의 흐름을 단위 테스트하면서 단순한 함수 결과에 대해 단언하고 싶을 때가 있다. 가령 compose 함수를 단위 테스트할 때 identity함수가 요긴하게 쓰인다
  - 캡술화가 형식에서 데이터를 함수형으로 추출한다

### **4.6.2 탭(K-조합기)**

- tap조합기는 코드 추가 없이 공형 함수를 연결하여 합성할 때 유용하다. 자신을 넘기고 자신을 돌려받는다

### **4.6.3 선택(OR-조합기)**

- alt 조합기는 함수 호출 시 기본 응답을 제공하는 단순 조건 로직을 수행한다. 함수 2개를 인수로 받아(false, null, undefined가 아닌)값이 있으면 첫 번째 함수의 결과를, 그렇지 않으면 두 번째 함수의 결과를 반환한다

```javascript
const alit = function(func1, func2) {
  return function(val) {
    return func1(val) || func2(val)
}

//람다 표현식으로 표현하기
const ale = R.curry((func1, func2, val) => func1(val) || func2(val))

```

### **4.6.4 순차열(S-조합기)**

- seq 조합기는 함수 순차열을 순회합니다. 2개 또는 더 많은 함수를 인수로 받아, 동일한 값에 대해 각 함수를 차례로 실행하는 또 다른 함수를 반환한다

```javascript
const seq = function () {
  const funcs = Array.prototype.slice.call(arguments);
  return function (val) {
    funcs.forEach(function (val) {
      fn(val);
    });
  };
};
```

- 이 조합기를 이용하면 서로 연관되어 있지만 독립적인 일연의 연산을 수행할 수 있다

### **4.6.5 포크(조인) 조합기**

- fork 조합기는 하나의 자원을 두 가지 방법으로 처리한 후 그 결과를 다시 조합한다. 하나의 join 함수와 주어진 입력을 처리할 종단 함수 2개를 받는다
- 분기된 각 함수의 결과는 제일 마지막에 인수2개를 받는 join 함수에 전달된다

```javascript
const fork = function (join, func1, func2) {
  return function (val) {
    return join(func1(val), func2(val));
  };
};
```

- 예 1: 점수 배열을 받아 평균점수를 구하는 문제

  ```javascript
  const computeAverageGrade = R.compose(
    getLetterGrade,
    fork(R.divide, R.sum, R.length)
  );

  computeAverageGrage([99, 80, 89]); //'B'
  ```

- 조합기를 쓰면 자유롭게 무인수 프로그래밍을 할 수 있다. 조합기는 순수하기 때문에 다른 조합기와 재합성이 가능하고, 결국 어떤 종류의 애플리케이션을 작성하더라도 무수히 많은 방법으로 표현할 수 있고 복잡성도 줄일 수 있다
- 함수형 프로그래밍은 불변성, 순수성이 기본 원리이므로 프로그램을 구성하는 함수의 모듈성과 재사용성을 세세하게 조절할 수 있다. 자바스크립트에서는 함수를 이용해서 모듈을 구현할 수 있다. 마찬가지로 전체 모듈을 합성하고 재사용하는 일도 얼마든지 가능하다
- 모듈적인 함수형 프로그래밍은 이해하기 쉽고 독립적으로 재사용 가능한 추상적인 함수들로 이루어진다. 덕분에 함수를 합성한 규칙만 봐도 전체 의미를 도출할 수 있다
- 순수한수의 합성은 함수형 프로그래밍의 근본이다

## **4.7 마치며**

- 함수형 체인과 파이프라인은 재사용 가능한, 모듈적인 프로그램 조각들을 연결한다
- 람다JS는 커링과 합성이 주특기인 함수형 라이브러리입니다. 아주 강력한 유틸리티 함수로 가득 차 있다
- 커링, 부분 적용을 하면 함수 인수를 일부만 평가하거나 단항 함수로 변환하여 함수 항수를 낮출 수 있다
- 작업을 단순한 함수들로 쪼갠 후 다시 조합하는 식으로 전체 해법에 도달한다
- 함수 조합기를 쓰면 실무에서 복잡한 프로그램의 흐름을 조화롭게 편성하고 무인수 스타일로 개발할 수 있다
